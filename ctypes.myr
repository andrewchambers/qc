use std

pkg qc =

	type ctype = union
		`Typrim cprim
		`Tyaggr caggr#
		`Tyvoid
	;;

	type cprim = union
		`Tylong
		`Tyint
		`Tychar
	;;

	type caggr = union
		`Typtr ctype
		`Tyarr carr
		`Tystruct std.option(cstruct)
		`Tyfunc cfunc
	;;
	
	type cstruct = struct
		isunion : bool
		align : uint32
		size : uint32
		membs : (std.option(byte[:]), ctype)[:]
		offsets : uint32[:]
		exports : std.htab(byte[:], (uint32, ctype))#
	;;

	type carr = struct
		len : uint32
		subty : ctype
	;;

	type cfunc = struct
		rty : ctype
		params : (std.option(byte[:]), ctype)[:]
		isvararg : bool
	;;
	
	const typesize : (ty : ctype -> std.option(uint32))
	const typealign : (ty : ctype -> std.option(uint32))
	
	const mkcstruct : (isunion : bool -> cstruct)
	const addtostruct : (s : cstruct#, namety : (std.option(byte[:]), ctype) -> void)
	const finalizestruct : (s : cstruct# -> void)
	const structmemb : (s : cstruct, name : byte[:] -> std.option((uint32, ctype)))
;;


const typealign = {ty
	var align
	
	match ty
	| `Typrim `Tylong:
		align = 8
	| `Typrim `Tyint:
		align = 4
	| `Typrim `Tychar:
		align = 1
	| `Tyaggr &(`Typtr _):
		align = 8
	| `Tyaggr &(`Tyarr arr):
		-> typealign(arr.subty)
	| `Tyaggr &(`Tystruct `std.None):
		-> `std.None
	| `Tyaggr &(`Tystruct `std.Some s):
		align = s.align
	| _:
		std.fatal("unimplemented typesize\n")
	;;
	-> `std.Some align
}

const typesize = {ty
	var sz
	
	match ty
	| `Typrim `Tylong:
		sz = 8
	| `Typrim `Tyint:
		sz = 4
	| `Typrim `Tychar:
		sz = 1
	| `Tyaggr &(`Typtr _):
		sz = 8
	| `Tyaggr &(`Tyarr arr):
		match typesize(arr.subty)
		| `std.None:
			-> `std.None
		| `std.Some subtysz:
			sz = arr.len * subtysz
		;;
	| `Tyaggr &(`Tystruct `std.None):
		-> `std.None
	| `Tyaggr &(`Tystruct `std.Some s):
		sz = s.size
	| _:
		std.fatal("unimplemented typesize\n")
	;;
	-> `std.Some sz
}

const alignoff = {v, a
	if v % a != 0
		-> v + a - (v % a)
	;;
	-> v
}

const mkcstruct = {isunion
	-> [
		.isunion = isunion,
		.align = 1,
		.size = 0,
		.membs = [][:],
		.offsets = [][:],
		.exports=std.mkht(std.strhash, std.streq),
	]
}

const addtostruct = {s, namety
	/* XXX: check if size is complete */
	std.slpush(&s.membs, namety)
}

const finalizestruct = {s
	var curoffset
	
	/* calc alignment */
	for (_, ty) in s.membs
		s.align = alignoff(s.align, std.get(typealign(ty)))
	;;
	
	/* calc member offsets */
	if s.isunion
		for (name, ty) in s.membs
			std.slpush(&s.offsets, 0)
			if std.get(typesize(ty)) > s.size
				s.size = std.get(typesize(ty))
			;;
		;;
	else
		curoffset = 0
		for (name, ty) in s.membs
			curoffset = alignoff(curoffset, std.get(typealign(ty)))
			std.slpush(&s.offsets, curoffset)
			curoffset += std.get(typesize(ty))
		;;
		s.size = curoffset
	;;
	/* exports including anonymous subunions */
	for (i, (name, ty)) in std.byenum(s.membs)
		match name
		| `std.None:
			match ty
			| `Tyaggr &(`Tystruct `std.Some sub):
				for (xname, (xoff, xty)) in std.htbykeyvals(sub.exports)
					// XXX check for duplicates
					std.htput(s.exports, xname, (s.offsets[i]+xoff, xty))
				;;
			| _:
				continue
			;;
		| `std.Some n:
			// XXX check for duplicates
			std.htput(s.exports, n, (s.offsets[i], ty))
		;;
	;;
	s.size = alignoff(s.size, s.align)
}

const structmemb = {s, name
	-> std.htget(s.exports, name)
}
