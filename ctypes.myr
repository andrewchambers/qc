use std

pkg qc =

	type ctype = union
		`Typrim cprim
		`Tyaggr caggr#
	;;

	type cprim = union
		`Tyint
		`Tyvoid
	;;

	type caggr = union
		`Typtr ctype
		`Tyarr carr
		`Tystruct std.option(cstruct)
		`Tyfunc cfunc
	;;
	
	type cstruct = struct
		membs : (std.option(byte[:]), ctype)[:]
	;;

	type carr = struct
		len : uint32
		subty : ctype
	;;

	type cfunc = struct
		rty : ctype
		params : (std.option(byte[:]), ctype[:])
		isvararg : bool
	;;
	
	const typesize : (ty : ctype -> std.option(uint32))
	const structmemb : (s : cstruct, name : byte[:] -> std.option((ctype, uint32)))
;;

const typesize = {ty
	var sz

	match ty
	| `Typrim `Tyint:
		/* XXX wrong, but ok for now */
		sz = 8
	| `Tyaggr &(`Typtr _):
		sz = 8
	| `Tyaggr &(`Tyarr arr):
		match typesize(arr.subty)
		| `std.None:
			-> `std.None
		| `std.Some subtysz:
			sz = arr.len * subtysz
		;;
	| `Tyaggr &(`Tystruct `std.None):
		-> `std.None
	| `Tyaggr &(`Tystruct `std.Some s):
		sz = 0
		for (_, membty) in s.membs
			 match typesize(membty)
			 | `std.None:
			 	-> `std.None
			 | `std.Some membsz:
			 	sz += membsz
			 ;;
		;;
	| _:
		std.fatal("unimplemented typesize\n")
	;;
	-> `std.Some sz
}

const structmemb = {s, name
	var off
	
	off = 0
	for (n, ty) in s.membs
		match n
		| `std.Some membname:
			if std.sleq(name, membname)
				-> `std.Some (ty, off)
			;;
		| `std.None:
		;;	
		match typesize(ty)
		| `std.None:
			-> `std.None
		| `std.Some msz:
			off += msz
		;;
	;;
	-> `std.None
}
