use std
use "tok"
use "err"
use "ctypes"
use "ast"

pkg qc =
	const parse : (ts : tokstream# -> node#[:])
;;

const mklocal = {p, name, ty
	var l
	
	l = std.mk([.ty=ty, .name=name])
	std.slpush(&p.curfunc.locals, l)
	-> l
}

type lblstate = union
	`Lblforward (srcloc, int)
	`Lbldefined int
;;

type parser = struct
	ts : tokstream#
	toks : (srcloc, tok)[2]
	stab : std.htab(byte[:], sym)#[:]
	lbltab : std.htab(byte[:], lblstate)#
	curfunc : func#
;;

const pushscope = {p
	std.slpush(&p.stab, std.mkht(std.strhash, std.streq))
}

const popscope = {p
	var ht
	
	(ht, p.stab) = std.slpop(p.stab)
	std.htfree(ht)
}

const declare = {p, name, sym
	if std.hthas(p.stab[p.stab.len-1], name)
		-> false
	;;
	std.htput(p.stab[p.stab.len-1], name, sym)
	-> true
}

const lookup = {p, name
	for var i = p.stab.len-1; ; i--
		match std.htget(p.stab[i], name)
		| `std.Some sym:
			-> `std.Some sym
		| `std.None:
		;;
	;;
	-> `std.None
}

const parse = {ts
	var p : parser#
	var stab, globals
	
	stab = [][:]
	
	p = std.mk([
		.ts = ts,
		.stab = stab,
	])
	p.toks[0] = toknext(ts)
	p.toks[1] = toknext(ts)
	
	globals = [][:]
	while true
		match peek(p)
		| (_, `Teof):
			break
		| _:
			std.slpush(&globals, parsefunc(p))
		;;
	;;
	-> globals
}

const next = {p
	var t = p.toks[0]
	p.toks[0] = p.toks[1]
	p.toks[1] = toknext(p.ts)
	-> t
}

const peek = {p
	-> p.toks[0]
}

const lookahead = {p
	-> p.toks[1]
}

const parsetype = {p
	match next(p)
	| (_, `Tint):
		-> `Typrim `Tyint
	| (l, _):
		err(l, "expected type\n")
	;;
}

const parsefunc = {p
	var rettype, fname, args
	var argname, argtype
	
	args = [][:]
	
	p.lbltab = std.mkht(std.strhash, std.streq)
	rettype = parsetype(p)
	match next(p)
	| (l, `Tident name):
		fname = name
	| (l, tok):
		err(l, "expected function name\n", tok)
	;;
	
	match next(p)
	| (_, `Toparen):
		match peek(p)
		| (_, `Tcparen):
			next(p)
			goto endparams
		| _:
			while true
				argtype = parsetype(p)
				match next(p)
				| (l, `Tident name):
					argname = name
				| (l, _):
					err(l, "expected parameter name\n")
				;;
				std.slpush(&args, (argname, argtype))
				match next(p)
				| (l, `Tcparen):
					break
				| (l, `Tcomma):
				| (l, _):
					err(l, "expected ',' or ')'\n")
				;;
			;;
		;;
	| (l, _):
		err(l, "expected function parameters")
	;;
	:endparams
	p.curfunc = std.mk( [
		.name = fname,
		.rettype = rettype,
		.args = args,
		.locals = [][:],
		.body = [][:],
		.lblcnt = 0,
	])
	p.curfunc.body = parseblock(p)
	for name in std.htkeys(p.lbltab)
		match std.get(std.htget(p.lbltab, name))
		| `Lblforward (lblpos, _):
			err(lblpos, "'{}' not defined\n", name)
		| _:
		;;
	;;
	std.htfree(p.lbltab)
	-> std.mk(`Nfunc p.curfunc)
}

const expectoparen = {p
	match next(p)
	| (_, `Toparen):
	| (l, _):
		err(l, "expected '('\n")
	;;
}

const expectcparen = {p
	match next(p)
	| (_, `Tcparen):
	| (l, _):
		err(l, "expected ')'\n")
	;;
}

const expectcsqbrac = {p
	match next(p)
	| (_, `Tcsqbrac):
	| (l, _):
		err(l, "expected ']'\n")
	;;
}

const parseif = {p
	var cond, iftrue, iffalse
	
	next(p)
	expectoparen(p)
	cond = parseexpr(p)
	expectcparen(p)
	iftrue = parsestmt(p)
	match peek(p)
	| (_, `Telse):
		next(p)
		iffalse = `std.Some parsestmt(p)
	| _:
		iffalse = `std.None
	;;
	-> std.mk(`Sif [
		.cond=cond,
		.iftrue=iftrue,
		.iffalse=iffalse,
		.truelbl=nextlbl(p.curfunc),
		.falselbl=nextlbl(p.curfunc),
		.donelbl=nextlbl(p.curfunc),
	])
}

const parsewhile = {p
	var cond, stmt
	
	next(p)
	expectoparen(p)
	cond = parseexpr(p)
	expectcparen(p)
	stmt = parsestmt(p)
	
	-> std.mk(`Swhile [
		.cond=cond,
		.stmt=stmt,
		.contlbl=nextlbl(p.curfunc),
		.stmtlbl=nextlbl(p.curfunc),
		.breaklbl=nextlbl(p.curfunc),
	])
}

const parsedowhile = {p
	var cond, stmt
	
	next(p)
	stmt = parsestmt(p)
	match next(p)
	| (_, `Twhile):
	| (l, _):
		err(l, "expected 'while'\n")
	;;
	expectoparen(p)
	cond = parseexpr(p)
	expectcparen(p)
	expectsemi(p)
	
	-> std.mk(`Sdowhile [
		.cond=cond,
		.stmt=stmt,
		.contlbl=nextlbl(p.curfunc),
		.stmtlbl=nextlbl(p.curfunc),
		.breaklbl=nextlbl(p.curfunc),
	])
}

const parsefor = {p
	var forstmt
	
	next(p)
	expectoparen(p)
	match peek(p)
	| (_, `Tsemi):
		forstmt.init = `std.None
		next(p)
	| _:
		forstmt.init = `std.Some parseexpr(p)
		expectsemi(p)
	;;
	match peek(p)
	| (_, `Tsemi):
		forstmt.cond = `std.None
		next(p)
	| _:
		forstmt.cond = `std.Some parseexpr(p)
		expectsemi(p)
	;;
	match peek(p)
	| (_, `Tcparen):
		forstmt.step = `std.None
		next(p)
	| _:
		forstmt.step = `std.Some parseexpr(p)
		expectcparen(p)
	;;
	forstmt.stmt = parsestmt(p)
	forstmt.contlbl=nextlbl(p.curfunc)
	forstmt.stmtlbl=nextlbl(p.curfunc)
	forstmt.breaklbl=nextlbl(p.curfunc)
	-> std.mk(`Sfor forstmt)
}

const parseblock = {p
	var stmts
	
	stmts = [][:]
	match next(p)
	| (l, `Tobrace):
	| (l, _):
		err(l, "expected '{'\n")
	;;
	pushscope(p)
	while true
		match peek(p)
		| (_, `Tcbrace):
			next(p)
			break
		| _:
			std.slpush(&stmts, parsedeclorstmt(p))
		;;
	;;
	popscope(p)
	-> stmts
}

const expectsemi = {p
	match next(p)
	| (l, `Tsemi):
	| (l, t):
		err(l, "expected ';', got {}", t)
	;;
}

const startofdecl = {p
	match peek(p)
	| (_, `Tstruct):
	| (_, `Tint):
	| (_, `Tvoid):
	| (_, `Tident n):
		/* XXX lookup type */
		-> false
	| _:
		-> false
	;;
	-> true
}

const parsetagtype = {p
	match next(p)
	| (_, `Tstruct):
	| (l, _):
		err(l, "expected 'struct'\n")
	;;
	match peek(p)
	| (_, `Tident tagname):
		next(p)
	| (l, _):
	;;
	match peek(p)
	| (_, Tcbrace):
	| (l, _):
		err(l, "unimplemented tag\n")
	;;
	-> parsestructbody(p)
}

const parsestructbody = {p
	var sc, basety
	var namety, membs 
	
	membs = [][:]
	match next(p)
	| (l, `Tobrace):
	| (l, _):
		err(l, "expected '{'\n")
	;;
	while true
		match peek(p)
		| (_, `Tcbrace):
			break
		| _:
		;;
		(sc, basety) = parsedeclspecs(p);
		while true
			namety = parsedecl(p, basety);
			std.slpush(&membs, namety)
			match peek(p)
			| (_, `Tcomma):
				next(p)
			| _:
				break
			;;
		;;
		expectsemi(p);
	;;
	next(p)
	-> `Tyaggr std.mk(`Tystruct [.membs=membs])
}

const parsedeclspecs = {p
	match peek(p)
	| (l, `Tint):
		next(p)
		-> (`Sclasslocal, `Typrim `Tyint)
	| (l, `Tstruct):
		-> (`Sclasslocal, parsetagtype(p))
	| (l, _):
		err(l, "expected a type specifier or storage class\n")
	;;
}

const parsedecl = {p, basety
	match peek(p)
	| (_, `Tmul):
		next(p)
		-> parsedecl(p, `Tyaggr std.mk(`Typtr basety))
	| _:
		-> parsedirectdecl(p, basety)
	;;
}

const parsedirectdecl = {p, basety
	match peek(p)
	| (_, `Tident name):
		next(p)
		-> (`std.Some name, parsedecltail(p, basety))
	| _:
		-> (`std.None, parsedecltail(p, basety))
	;;
}

const parsedecltail = {p, basety
	var len
	
	while true
		match peek(p)
		| (l, `Tosqbrac):
			next(p)
			match peek(p)
			| (_, `Tcsqbrac):
				err(l, "unimplemented inferred arr size")
			| _:
			;;
			len = parseconstexpr(p) castto(uint32)
			expectcsqbrac(p)
			-> `Tyaggr std.mk(`Tyarr [.len=len, .subty=basety])
		| _:
			-> basety
		;;
	;;
	std.die("unreachable\n")
}

const parsedeclaration = {p
	var sclass, name, ty, sym
	var loc
	
	match peek(p)
	| (l, _):
		loc = l
	;;
	(sclass, ty) = parsedeclspecs(p)
	(name, ty) = parsedecl(p, ty)
	match name
	| `std.Some n:
		sym = `Symlocal mklocal(p, n, ty)
		if !declare(p, n, sym)
			err(loc, "redefinition of {}\n", n)
		;;
		expectsemi(p)
		-> std.mk(`Sdecl [.name=n, .sym=sym])
	| `std.None:
		err(loc, "declaration defines no name\n")
	;;
}

const parsedeclorstmt = {p	
	if startofdecl(p)
		-> parsedeclaration(p)
	;;
	-> parsestmt(p)
}

const parsestmt = {p
	var expr
	
	match (peek(p), lookahead(p))
	| ((_, `Tident _), (_, `Tcolon)):
		-> parselabeled(p)
	| _:
	;;
	
	match peek(p)
	| (_, `Tsemi):
		next(p)
		-> std.mk(`Sempty)
	| (_, `Tif):
		-> parseif(p)
	| (_, `Tgoto):
		-> parsegoto(p)
	| (_, `Tfor):
		-> parsefor(p)
	| (_, `Twhile):
		-> parsewhile(p)
	| (_, `Tdo):
		-> parsedowhile(p)
	| (l, `Treturn):
		-> parsereturn(p)
	| (l, `Tobrace):
		-> std.mk(`Sblock parseblock(p))
	| _:
		expr = parseexpr(p)
		expectsemi(p)
		-> std.mk(`Sexpr expr)
	;;
}


const parsegoto = {p
	var loc, name, lbl
	
	(loc, _) = next(p)
	match next(p)
	| (_, `Tident n):
		name = n
	| (l, _):
		err(l, "expected 'identifier'\n")
	;;
	
	match std.htget(p.lbltab, name)
	| `std.None:
		lbl = nextlbl(p.curfunc)
		std.htput(p.lbltab, name, `Lblforward (loc, lbl))
	| `std.Some `Lblforward (_, l):
		lbl = l
	| `std.Some `Lbldefined l:
		lbl = l
	;;
	-> std.mk(`Sgoto lbl)
}

const parselabeled = {p
	var loc, name, lbl
	
	match next(p)
	| (l, `Tident n):
		loc = l
		name = n
	| (l, _):
		err(l, "expected 'identifier'\n")
	;;
	match next(p)
	| (_, `Tcolon):
	| (l, _):
		err(l, "expected ':'\n")
	;;
	lbl = nextlbl(p.curfunc)
	match std.htget(p.lbltab, name)
	| `std.None:
		lbl = nextlbl(p.curfunc)
	| `std.Some `Lblforward (_, l):
		lbl = l
	| `std.Some `Lbldefined _:
		err(loc, "label '{}' redefined\n", name)
	;;
	std.htput(p.lbltab, name, `Lbldefined lbl)
	-> std.mk(`Slabeled [.lbl=lbl, .stmt=parsestmt(p)])
}

const parsereturn= {p
		var rexpr
		
		next(p)
		rexpr = parseexpr(p)
		expectsemi(p)
		-> std.mk(`Sreturn rexpr)
}

const parseexpr = {p
	-> parseassign(p)
}

const parseconstexpr = {p
	match next(p)
	| (_, `Tintlit n):
		-> n
	| (l, _):
		err(l, "expected a constant expression\n")
	;;
}

const parseassign = {p
	var l, r
	
	l = parseeqlexpr(p)
	match peek(p)
	| (_, `Tasn):
	| _:
		-> l
	;;
	next(p)
	r = parseassign(p)
	-> std.mk(`Eassign [.ty=`Typrim `Tyint, .op=`Oasn, .l=l, .r=r])
}

const parseeqlexpr = {p
	var l, r, op
	
	l = parseaddexpr(p)
	while true
		match peek(p)
		| (_, `Teq):
			op = `Oeq
		| (_, `Tne):
			op = `One
		| _:
			break
		;;
		next(p)
		r = parseaddexpr(p)
		l = std.mk(`Ebinop [.ty=`Typrim `Tyint, .op=op, .l=l, .r=r])
	;;
	-> l
}

const parseaddexpr = {p
	var l, r, op
	
	l = parsemulexpr(p)
	while true
		match peek(p)
		| (_, `Tplus):
			op = `Oplus
		| (_, `Tminus):
			op = `Ominus
		| _:
			break
		;;
		next(p)
		r = parsemulexpr(p)
		l = std.mk(`Ebinop [.ty=`Typrim `Tyint, .op=op, .l=l, .r=r])
	;;
	-> l
}

const parsemulexpr = {p
	var l, r, op
	
	l = parseunop(p)
	while true
		match peek(p)
		| (_, `Tmul):
			op = `Omul
		| (_, `Tdiv):
			op = `Odiv
		| (_, `Tmod):
			op = `Omod
		| _:
			break
		;;
		next(p)
		r = parseunop(p)
		l = std.mk(`Ebinop [.ty=`Typrim `Tyint, .op=op, .l=l, .r=r])
	;;
	-> l
}

const parseunop = {p
	var operand
	
	match peek(p)
	| (l, `Tband):
		next(p)
		operand = parseunop(p)
		-> std.mk(`Eunop [.ty=`Typrim `Tyint, .op=`Oaddr, .operand=operand])
	| (l, `Tmul):
		next(p)
		operand = parseunop(p)
		-> std.mk(`Eunop [.ty=`Typrim `Tyint, .op=`Oderef, .operand=operand])
	| _:
		-> parsepostexpr(p)
	;;
}


const parsepostexpr = {p
	var expr, idx
	var selstruct, seloff, selty
	
	expr = parseprimaryexpr(p)
	while true
		match peek(p)
		| (l, `Tosqbrac):
			next(p)
			idx = parseexpr(p)
			expectcsqbrac(p)
			expr = std.mk(`Eidx [.ty=`Typrim `Tyint, .expr=expr, .idx=idx])
		| (l, `Tdot):
			next(p)
			match exprtype(expr)
			| (`Tyaggr &(`Tystruct s)):
				selstruct = s
			| _:
				err(l, "'.' can only be used on structs or unions\n")
			;;
			match next(p)
			| (selloc, `Tident name):
				match structmemb(selstruct, name)
				| `std.Some (ty, off):
					seloff = off
					selty = ty
				| `std.None:
					err(selloc, "struct has no member {}\n", name)
				;;
			| (selloc, _):
				err(selloc, "expected 'identifier'")
			;;
			expr = std.mk(`Esel [.ty=selty, .expr=expr, .off=seloff])
		| _:
			break
		;;
	;;
	-> expr
}

const parseprimaryexpr = {p
	var expr
	
	match next(p)
	| (l, `Tident n):
		match lookup(p, n)
		| `std.Some sym:
			-> std.mk(`Eident sym)
		| `std.None:
			err(l, "undefined symbol {}\n", n)
		;;
	| (l, `Tintlit v):
		-> std.mk(`Eintlit v)
	| (_, `Toparen):
		expr = parseexpr(p)
		expectcparen(p)
		-> expr
	| (l, t):
		err(l, "expected 'integer literal, got {}'\n", t)
	;;	
}

