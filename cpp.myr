use std
use "err"
use "tok"

pkg qc =
	type pp = struct
		input : tokstream#[:]
		incpath : byte[:]
		sysincpaths : byte[:][:]
		expanded : tok[:]
		
		macros : std.htab(byte[:], macro)#
	;;
	
	type objmacro = struct
		toks : tok[:]
	;;
	
	type funcmacro = struct
		params : byte[:][:]
		toks : tok[:]
	;;
	
	type macro = union
		`Mobj objmacro#
		`Mfunc funcmacro#
	;;
	
	const mkcpp : (ts : tokstream#, incpath : byte[:] ,sysincpaths : byte[:][:] -> pp#) 
	const cppnext : (pp : pp# -> tok)
;;

const mkcpp = {ts, incpath, sysincpaths
	var pp
	
	pp = std.mk([
		.input=[][:],
		.incpath=incpath,
		.sysincpaths=sysincpaths,
		.expanded=[][:],
		.macros=std.mkht(std.strhash, std.streq)
	])
	pushts(pp, ts)
	-> pp
}

const cppnextnoexp = {pp
	var tok
	
	if pp.expanded.len != 0
		tok = std.slpop(&pp.expanded)
	else
		tok = toknext(pp.input[pp.input.len-1])
	;;
	
	-> tok
}

const peeknoexp = {pp
	var tok
	
	tok = cppnextnoexp(pp)
	std.slpush(&pp.expanded, tok)
	
	-> tok
}

const cppnext = {pp
	var tok
	
	tok = cppnextnoexp(pp)
	
	match std.htget(pp.macros, tok.text)
	| `std.Some `Mobj m:
		for t in m.toks
			std.slpush(&pp.expanded, t)
		;;
		-> cppnext(pp)
	| `std.Some `Mfunc m:
		err(tok.loc, "unimplemented funclike macros\n")
	| `std.None:
	;;
	
	match tok.kind
	| `Tdirective:
		directive(pp)
		-> cppnext(pp)
	| `Teof:
		if pp.input.len > 1
			std.slpop(&pp.input)
			-> cppnext(pp)
		;;
	| _:
	;;
	-> tok
}

const pushts = {pp, ts
	std.slpush(&pp.input, ts)
}

const directive = {pp
	var tok
	
	tok = cppnext(pp)
	match tok.text
	| "include":
		dirinclude(pp)
	| "define":
		dirdefine(pp)
	| dir:
		err(tok.loc, "bad directive {}\n", dir)
	;;
}

const findsysinc = {pp, header
	for ipath in pp.sysincpaths
		var fullpath = std.pathjoin([ipath, header][:])
		if std.fexists(fullpath)
			-> `std.Some fullpath
		;;
		std.slfree(fullpath)
	;;
	-> `std.None
}

const findinc = {pp, header
	var incpath 
	
	incpath = std.pathjoin([pp.incpath, header][:])
	if std.fexists(incpath)
		-> `std.Some incpath
	;;
	std.slfree(incpath)
	-> findsysinc(pp, header)
}

const dirinclude = {pp
	var tok, path, ts
	
	tok = cppnextnoexp(pp)
	match tok.kind
	| `Tsysincl s:
		match findsysinc(pp, s)
		| `std.Some found:
			path = found
		| `std.None:
			err(tok.loc, "{} not in include path\n", s)
		;;
	| `Tstrlit s:
		match findinc(pp, s)
		| `std.Some found:
			path = found
		| `std.None:
			err(tok.loc, "{} not in include path\n", s)
		;;
	| _:
		err(tok.loc, "bad include, expected a string\n")
	;;
	tok = cppnextnoexp(pp)
	match tok.kind
	| `Tenddirective:
	| _:
		err(tok.loc, "junk '{}' at end of include directive\n", tok.text)
	;;
	ts = tokinit(path)
	pushts(pp, ts)
}

const validmacroparam = {s
	// XXX todo
	-> true
}

const dirdefine = {pp
	var toks, tok, name
	var isfuncmacro, mparams

	isfuncmacro = false
	mparams = [][:]	
	toks = [][:]
	
	tok = cppnextnoexp(pp)
	match tok.kind
	| `Tenddirective:
		err(tok.loc, "define expects something to define\n")
	| _:
		name = tok.text
		if std.hthas(pp.macros, name)
			err(tok.loc, "redefinition of macro {}\n", name)
		;;
	;;
	
	tok = peeknoexp(pp)
	match tok.kind
	| `Toparen:
		cppnextnoexp(pp)
		isfuncmacro = true
		tok = cppnextnoexp(pp)
		while true
			if !validmacroparam(tok.text)
				err(tok.loc, "{} is not a valid macro param\n", tok.text)
			;;
			std.slpush(&mparams, tok.text)
			tok = cppnextnoexp(pp)
			match tok.kind
			| `Tcomma:
			| _:
				break
			;;
		;;
		tok = cppnextnoexp(pp)
		match tok.kind
		| `Tcparen:
		| _:
			err(tok.loc, "expected ')' to end macro param list\n")
		;;
	| _:
	;;
	
	while true
		tok = cppnextnoexp(pp)
		match tok.kind
		| `Tenddirective:
			break
		| _:
			std.slpush(&toks, tok)
		;;
	;;
	
	if isfuncmacro
		std.htput(pp.macros, name, `Mfunc std.mk([.params=mparams, .toks=toks]))
	else
		std.htput(pp.macros, name, `Mobj std.mk([.toks=toks]))
	;;
	
}

