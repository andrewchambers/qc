use std
use "err"
use "tok"

pkg qc =
	type pp = struct
		input : tokstream#[:]
		includedirs : byte[:][:]
	;;
	
	const mkcpp : (ts : tokstream# -> pp#) 
	const cppnext : (pp : pp# -> tok)
;;

const mkcpp = {ts
	var pp
	
	pp = std.mk([.input=[][:], .includedirs=[][:]])
	pushts(pp, ts)
	-> pp
}

const cppnext = {pp
	var tok
	
	tok = toknext(pp.input[pp.input.len-1])
	match tok.kind
	| `Tdirective:
		directive(pp)
		-> cppnext(pp)
	| `Teof:
		if pp.input.len > 1
			std.slpop(&pp.input)
			-> cppnext(pp)
		;;
	| _:
	;;
	-> tok
}

const pushts = {pp, ts
	std.slpush(&pp.input, ts)
}

const directive = {pp
	var tok
	
	tok = cppnext(pp)
	match tok.text
	| "include":
		dirinclude(pp)
	| dir:
		err(tok.loc, "bad directive {}\n", dir)
	;;
}

const findsysinc = {pp, path
	for ipath in pp.includedirs
		var fullpath = std.pathjoin([ipath, path][:])
		if std.fexists(fullpath)
			-> `std.Some fullpath
		;;
		std.slfree(fullpath)
	;;
	-> `std.None
}

const findinc = {pp, path
	if std.fexists(path)
		-> `std.Some std.sldup(path)
	;;
	-> findsysinc(pp, path)
}

const dirinclude = {pp
	var tok, path, ts
	
	tok = cppnext(pp)
	match tok.kind
	| `Tstrlit s:
		match findinc(pp, s)
		| `std.Some found:
			path = found
		| `std.None:
			err(tok.loc, "{} not in include path\n", s)
		;;
	| _:
		err(tok.loc, "bad include, expected a string\n")
	;;
	tok = cppnext(pp)
	match tok.kind
	| `Tenddirective:
	| _:
		err(tok.loc, "junk at end of include directive {}", tok.text)
	;;
	ts = tokinit(path)
	pushts(pp, ts)
}


