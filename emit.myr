use std

use "parse"

pkg qc =
	const emit : (globals : node#[:] -> void)
;;

type Val = union
	`Vlit int64
	`Vreg byte[:]
;;

var allocas : std.htab(local#, Val)#
var nreg = 0

const newreg = {
	-> `Vreg std.fmt("%v{}", nreg++) 
}

const newnamedreg = {name
	-> `Vreg std.fmt("%v{}.{}", nreg++, name)
}

const emit = {globals
	for g in globals
		match g
		| &(`Nfunc f):
			emitfunc(f)
		;;
	;;
}

const vo = {msg : byte[:], ap : std.valist#
	var sb, ln

	sb = std.mksb()
	std.sbfmtv(sb, msg, ap)
	ln = std.sbfin(sb)
	match std.writeall(std.Out, ln)
	| (_ ,`std.Some _):
		std.fatal("error writing output\n")
	| _:
	;;
	std.slfree(ln)
}

const o = {msg : byte[:], args : ...
	var ap
	
	ap = std.vastart(&args)
	vo(msg, &ap)
}

const oi = {msg : byte[:], args : ...
	var ap
	
	o("    ")
	ap = std.vastart(&args)
	vo(msg, &ap)
}

const valstr = {v
	match v
	| `Vlit n:
		-> std.fmt("{}", n) 
	| `Vreg name:
		-> name
	;;
}

const emitfunc = {f
	var alloca
	
	allocas = std.mkht({x; -> x castto(uint32)}, {x, y; -> x == y})
	nreg = 0
	o("function l ${}(", f.name)
	for (name, ty) in f.args
		o("l {},", name)
	;;
	o(") {{\n")
	o("  @start\n")
	
	for l in f.locals
		alloca = newnamedreg(l.name)
		std.htput(allocas, l, alloca)
		oi("{} =l alloc8 8\n", valstr(alloca))
	;;
	
	for stmt in f.body
		emitstmt(stmt)
	;;
	
	o("  @end\n")
	oi("ret 0\n")
	o("}}\n\n")
	std.htfree(allocas)
}

const emitstmt = {stmt
	var v
	
	match stmt
	| &(`Sreturn expr):
		v = emitexpr(expr)
		oi("ret {}\n", valstr(v))
	| &(`Sdecl _):
		/* Do nothing for now */
	| &(`Sexpr expr):
		emitexpr(expr)
	| _:
		std.fatal("unimplemented emitstmt: {}\n", stmt)
	;;
}

const lval = {expr
	match expr
	| &(`Eident `Symlocal local):
		-> std.get(std.htget(allocas, local))
	| _:
		std.die("not an lval\n")
	;;
}

const load = {val
	var v
	
	v = newreg()
	oi("{} =l loadl {}\n", valstr(v), valstr(val))
	-> v
}

const store = {dst, v
	oi("storel {}, {}\n", valstr(v), valstr(dst))
}

const emitexpr = {expr
	var v1, v2

	match expr
	| &(`Eintlit v):
		-> `Vlit v
	| &(`Ebinop b):
		-> emitbinop(b)
	| &(`Eident `Symlocal local):
		v1 = std.get(std.htget(allocas, local))
		-> load(v1)
	| &(`Eassign assign):
		v1 = lval(assign.l)
		v2 = emitexpr(assign.r)
		store(v1, v2)
		-> v2
	| _:
		std.fatal("unimplemented emitexpr: {}\n", expr)
	;;
}

const emitbinop = {b
	var l, r, o, result
	
	l = emitexpr(b.l)
	r = emitexpr(b.r)
	result = newreg()
	match b.op
	| `Oplus:
		o = "add"
	| `Ominus:
		o = "sub"
	;;
	oi("{} =l {} {}, {}\n", valstr(result), o, valstr(l), valstr(r))
	-> result
}

