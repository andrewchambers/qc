use std

use "parse"
use "ctypes"
use "ast"

pkg qc =
	const emit : (globals : node#[:] -> void)
;;

type Val = union
	`Vlit int64
	`Vreg byte[:]
;;

type data = struct
	isglobal : bool
	label : byte[:]
	val : union
		`Dstr byte[:]
		`Dzero uint32
	;;
;;

var allocas : std.htab(sym#, Val)#
var pendingdata : data#[:]

var nreg = 0
const newreg = {
	-> `Vreg std.fmt("%v{}", nreg++) 
}

var datalblcount = 0
const nextdatalbl = {
	-> datalblcount++
}

const newnamedreg = {name
	-> `Vreg std.fmt("%v{}.{}", nreg++, name)
}

const emit = {globals
	pendingdata = [][:]
	
	for g in globals
		match g
		| &(`Nfunc f):
			emitfunc(f)
		| &(`Ndecl decls):
			emitdecls(decls)
		;;
	;;
	emitpendingdata()
}

const emitdecls = {decls
	for decl in decls
		match decl
		| (sym, `std.None):
			match sym.ty
			| `Tyaggr &(`Tyfunc _):
				continue
			| _:
			;;
			match sym.sc
			| `Sclasstypedef:
				continue
			| `Sclassglobal:
				var d : data = [
					.isglobal= true,
					.label=sym.name,
					.val=`Dzero std.get(typesize(sym.ty)),
				]
				std.slpush(&pendingdata, std.mk(d))
			| _:
				std.fatal("internal error...\n")
			;;
		| _:
			std.fatal("unimplemented global decl")
		;;
	;;
}

const vo = {msg : byte[:], ap : std.valist#
	var sb, ln

	sb = std.mksb()
	std.sbfmtv(sb, msg, ap)
	ln = std.sbfin(sb)
	match std.writeall(std.Out, ln)
	| (_ ,`std.Some _):
		std.fatal("error writing output\n")
	| _:
	;;
	std.slfree(ln)
}

var unreachable = false

/* output functions abbreviated due to frequent use */
const o = {msg : byte[:], args : ...
	var ap
	
	ap = std.vastart(&args)
	vo(msg, &ap)
}

/* out instruction */
const oi = {msg : byte[:], args : ...
	var ap
	
	if unreachable 
		-> void
	;;
	o("    ")
	ap = std.vastart(&args)
	vo(msg, &ap)
}

/* out label */
const ol = {msg : byte[:], args : ...
	var ap
	
	o("  ")
	ap = std.vastart(&args)
	vo(msg, &ap)
	unreachable = false
}

/* out terminator */
const ot = {msg : byte[:], args : ...
	var ap
	
	if unreachable
		-> void
	;;
	
	o("    ")
	ap = std.vastart(&args)
	vo(msg, &ap)
	unreachable = true
}

const valstr = {v
	match v
	| `Vlit n:
		-> std.fmt("{}", n) 
	| `Vreg name:
		-> name
	;;
}

const emitfunc = {f
	var alloca, namestoparamregs, reg
	
	allocas = std.mkht({x; -> x castto(uint32)}, {x, y; -> x == y})
	nreg = 0
	
	o("function l ${}(", f.name)
	
	namestoparamregs = std.mkht(std.slhash, std.sleq)
	for var i = 0; i < f.functy.params.len; i++
		var name, ty
		(name, ty) = f.functy.params[i]
		match name
		| `std.Some n:
			reg = newnamedreg(n)
			o("l {}", valstr(reg))
			if i != f.functy.params.len - 1
				o(",")
			;;
			std.htput(namestoparamregs, n, reg)
		| `std.None:
			std.fatal("emit unimplemented param with no name\n")
		;;
	;;
	o(") {{\n")
	ol("@L{}\n", nextlbl(f))
	
	for l in f.locals
		alloca = newnamedreg(l.name)
		std.htput(allocas, l, alloca)
		oi("{} =l alloc16 {}\n", valstr(alloca), std.get(typesize(l.ty)))
	;;
	
	for param in f.params
		reg = std.get(std.htget(namestoparamregs, param.name))
		alloca = std.get(std.htget(allocas, param))
		emitstore(param.ty, alloca, reg)
	;;
	
	for stmt in f.body
		emitstmt(stmt)
	;;
	
	if !unreachable
		ot("ret 0\n")
	;;
	o("}}\n\n")
	std.htfree(allocas)
	std.htfree(namestoparamregs)
}

const emitcall = {call
	var result, args, v

	result = newreg()
	args = [][:]
	for arg in call.args
		v = emitexpr(arg)
		std.slpush(&args, v)
	;;
	match call.func
	| &(`Eident &([.name=name, .sc=`Sclassglobal])):
		oi("{} =l call ${}(", valstr(result), name)
		for var i = 0; i < args.len; i++
			var arg = args[i]
			o("l {}", valstr(arg))
			if i != args.len-1
				o(",")
			;;
		;;
		o(")\n")
	| _:
		std.fatal("function pointers are unimplemented\n")
	;;
	-> result
}


const emitstmt = {stmt
	var v
	
	match stmt
	| &(`Slabeled labeled):
		ol("@L{}\n", labeled.lbl)
		emitstmt(labeled.stmt)
	| &(`Sgoto lbl):
		ot("jmp @L{}\n", lbl)
	| &(`Sreturn expr):
		v = emitexpr(expr)
		ot("ret {}\n", valstr(v))
	| &(`Sexpr expr):
		emitexpr(expr)
	| &(`Sif ifsmt):
		emitif(ifsmt)
	| &(`Swhile whilestmt):
		emitwhile(whilestmt)
 	| &(`Sdowhile dowhilestmt):
		emitdowhile(dowhilestmt)
	| &(`Sfor forstmt):
		emitfor(forstmt)
	| &(`Sblock block):
		for substmt in block
			emitstmt(substmt)
		;;
	| &(`Sdecl _):
		/* do nothing for now */
	| &(`Sempty):
		/* empty */
	;;
}

const emitif = {ifstmt
	var cond
	
	cond = emitexpr(ifstmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), ifstmt.truelbl, ifstmt.falselbl)
	ol("@L{}\n", ifstmt.truelbl)
	emitstmt(ifstmt.iftrue)
	ot("jmp @L{}\n", ifstmt.donelbl)
	ol("@L{}\n", ifstmt.falselbl)
	match ifstmt.iffalse
	| `std.Some iffalse:
		emitstmt(iffalse)
	| `std.None:
	;;
	ol("@L{}\n", ifstmt.donelbl)
}

const emitfor = {forstmt
	var cond
	
	match forstmt.init
	| `std.Some expr:
		emitexpr(expr)
	| `std.None:
	;;
	ol("@L{}\n", forstmt.contlbl)
	match forstmt.cond
	| `std.Some expr:
		cond = emitexpr(expr)
		ot("jnz {}, @L{}, @L{}\n", valstr(cond), forstmt.stmtlbl, forstmt.breaklbl)
	| `std.None:
		ot("jmp @L{}\n", forstmt.stmtlbl)
	;;
	ol("@L{}\n", forstmt.stmtlbl)
	emitstmt(forstmt.stmt)
	match forstmt.step
	| `std.Some expr:
		emitexpr(expr)
	| `std.None:
	;;
	ot("jmp @L{}\n", forstmt.contlbl)
	ol("@L{}\n", forstmt.breaklbl)
}

const emitwhile = {whilestmt
	var cond
	
	ol("@L{}\n", whilestmt.contlbl)
	cond = emitexpr(whilestmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), whilestmt.stmtlbl, whilestmt.breaklbl)
	ol("@L{}\n", whilestmt.stmtlbl)
	emitstmt(whilestmt.stmt)
	ot("jmp @L{}\n", whilestmt.contlbl)
	ol("@L{}\n", whilestmt.breaklbl)
}

const emitdowhile = {whilestmt
	var cond
	
	ol("@L{}\n", whilestmt.stmtlbl)
	emitstmt(whilestmt.stmt)
	ol("@L{}\n", whilestmt.contlbl)
	cond = emitexpr(whilestmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), whilestmt.stmtlbl, whilestmt.breaklbl)
	ol("@L{}\n", whilestmt.breaklbl)
}

const emitlval = {expr
	var v
	
	match expr
	| &(`Eident sym):
		match sym.sc
		| `Sclassglobal:
			v = newreg()
			oi("{} =l copy ${}\n", valstr(v), sym.name)
			-> v
		| `Sclasslocal:
			-> std.get(std.htget(allocas, sym))
		| _:
			std.fatal("emitlval internal error\n")
		;;
	| &(`Eunop [.op=`Oderef, .operand=operand]):
		-> emitexpr(operand)
	| &(`Eidx idx):
		-> emitlidx(idx)
	| &(`Esel sel):
		-> emitlsel(sel)
	| _:
		std.fatal("not an lval\n")
	;;
}

const emitload = {val, ty
	var v
	
	match ty
	| `Tyaggr &(`Tyarr _):
		-> val
	| `Tyaggr &(`Tystruct _):
		-> val
	| _:
	;;
	
	v = newreg()
	match ty
	| `Typrim `Tychar:
		oi("{} =w loadsb {}\n", valstr(v), valstr(val))
	| `Typrim `Tyint:
		oi("{} =w load {}\n", valstr(v), valstr(val))
	| `Typrim `Tylong:
		oi("{} =l load {}\n", valstr(v), valstr(val))
	| `Tyaggr &(`Typtr _):
		oi("{} =l load {}\n", valstr(v), valstr(val))
	| _:
		std.fatal("unimplemented load {}\n", ty)
	;;
	-> v
}

const emitstore = {ty, dst, v
	match ty
	| `Typrim `Tychar:
		oi("storeb {}, {}\n", valstr(v), valstr(dst))
	| `Typrim `Tyint:
		oi("storew {}, {}\n", valstr(v), valstr(dst))
	| `Typrim `Tylong:
		oi("storel {}, {}\n", valstr(v), valstr(dst))
	| `Tyaggr &(`Typtr _):
		oi("storel {}, {}\n", valstr(v), valstr(dst))
	| _:
		std.fatal("unimplemented store {}\n", ty)
	;;
}

const emitexpr = {expr
	var v1, v2

	match expr
	| &(`Ecall call):
		-> emitcall(call)
	| &(`Ecast cast):
		-> emitcast(cast)
	| &(`Eidx idx):
		-> emitidx(idx)
	| &(`Eintlit v):
		-> `Vlit v
	| &(`Estrlit s):
		var d = [
			.isglobal=false,
			.label=std.fmt(".D{}", nextdatalbl()),
			.val=`Dstr s,
		]
		std.slpush(&pendingdata, std.mk(d) )
		v1 = newreg()
		oi("{} =l copy ${}\n", valstr(v1), d.label)
		-> v1
	| &(`Ebinop b):
		-> emitbinop(b)
	| &(`Eunop u):
		match u.op
		| `Oaddr:
			-> emitlval(u.operand)
		| `Oderef:
			v1 = emitexpr(u.operand)
			-> emitload(v1, u.ty)
		| _:
			std.fatal("unsupported unop: {}\n", u.op)
		;;
	| &(`Eident sym):
		v1 = emitlval(expr)
		-> emitload(v1, sym.ty)
	| &(`Eassign assign):
		v1 = emitlval(assign.l)
		v2 = emitexpr(assign.r)
		emitstore(assign.ty, v1, v2)
		-> v2
	| &(`Esel sel):
		-> emitsel(sel)
	;;
}

const emitcast = {cast
	-> emitexpr(cast.expr)
}

const emitlsel = {sel
	var v, p
	
	v = emitexpr(sel.expr)
	p = newreg()
	oi("{} =l add {}, {}\n", valstr(p), valstr(v), sel.off)
	-> p
}

const emitsel = {sel
	var p
	p = emitlsel(sel)
	-> emitload(p, sel.ty)
}

const emitlidx = {idx
	var v, i, p, off, sz
	
	v = emitexpr(idx.expr)
	i = emitexpr(idx.idx)
	off = newreg()
	sz = std.get(typesize(exprtype(idx.expr)))
	oi("{} =l mul {}, {}\n", valstr(off), sz, valstr(i))
	p = newreg()
	oi("{} =l add {}, {}\n", valstr(p), valstr(v), valstr(off))
	-> p
}

const emitidx = {idx
	var p
	
	p = emitlidx(idx)
	-> emitload(p, idx.ty)
}

const emitbinop = {b
	var l, r, o, result
	var width
	
	match b.ty
	| `Typrim `Tylong:
		width = "l"
	|  `Typrim `Tyint:
		width = "w"
	| _:
	;;
	
	l = emitexpr(b.l)
	r = emitexpr(b.r)
	result = newreg()
	match b.op
	| `Oplus:
		o = "add"
	| `Ominus:
		o = "sub"
	| `Odiv:
		o = "div"
	| `Omul:
		o = "mul"
	| `Omod:
		o = "rem"
	| `Oeq:
		o = "ceql"
	| `One:
		o = "cne"
	| `Olt:
		o = "csltl"
	| `Ogt:
		o = "csgt"
	| `Oge:
		o = "csge"
	| `Ole:
		o = "csle"
	;;
	
	oi("{} ={} {} {}, {}\n", valstr(result), width, o, valstr(l), valstr(r))
	-> result
}


const emitpendingdata = {
	for data in pendingdata
		match data.val
		| `Dzero sz:
			o("data ${} = {{z {}}}\n", data.label, sz)
		| `Dstr s:
			o("data ${} = {{b \"{}\", b 0}}\n", data.label, s)
		| _:
			std.fatal("unsupported data")
		;;
	;;
}
