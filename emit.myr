use std

use "parse"
use "ctypes"
use "ast"

pkg qc =
	const emit : (globals : node#[:] -> void)
;;

type Val = union
	`Vlit int64
	`Vreg byte[:]
;;

var allocas : std.htab(sym#, Val)#
var nreg = 0

const newreg = {
	-> `Vreg std.fmt("%v{}", nreg++) 
}

const newnamedreg = {name
	-> `Vreg std.fmt("%v{}.{}", nreg++, name)
}

const emit = {globals
	
	for g in globals
		match g
		| &(`Nfunc f):
			emitfunc(f)
		| &(`Ndecl decls):
			for decl in decls
				match decl
				| ([.sc=`Sclasstypedef], _):
					continue
				| _:
					std.fatal("unimplemented global decl")
				;;
			;;
		;;
	;;
}

const vo = {msg : byte[:], ap : std.valist#
	var sb, ln

	sb = std.mksb()
	std.sbfmtv(sb, msg, ap)
	ln = std.sbfin(sb)
	match std.writeall(std.Out, ln)
	| (_ ,`std.Some _):
		std.fatal("error writing output\n")
	| _:
	;;
	std.slfree(ln)
}

var unreachable = false

/* output functions abbreviated due to frequent use */
const o = {msg : byte[:], args : ...
	var ap
	
	ap = std.vastart(&args)
	vo(msg, &ap)
}

/* out instruction */
const oi = {msg : byte[:], args : ...
	var ap
	
	if unreachable 
		-> void
	;;
	o("    ")
	ap = std.vastart(&args)
	vo(msg, &ap)
}

/* out label */
const ol = {msg : byte[:], args : ...
	var ap
	
	o("  ")
	ap = std.vastart(&args)
	vo(msg, &ap)
	unreachable = false
}

/* out terminator */
const ot = {msg : byte[:], args : ...
	var ap
	
	if unreachable
		-> void
	;;
	
	o("    ")
	ap = std.vastart(&args)
	vo(msg, &ap)
	unreachable = true
}

const valstr = {v
	match v
	| `Vlit n:
		-> std.fmt("{}", n) 
	| `Vreg name:
		-> name
	;;
}

const emitfunc = {f
	var alloca, namestoparamregs, reg
	
	allocas = std.mkht({x; -> x castto(uint32)}, {x, y; -> x == y})
	nreg = 0
	
	o("function l ${}(", f.name)
	
	namestoparamregs = std.mkht(std.slhash, std.sleq)
	for var i = 0; i < f.functy.params.len; i++
		var name, ty
		(name, ty) = f.functy.params[i]
		match name
		| `std.Some n:
			reg = newnamedreg(n)
			o("l {}", valstr(reg))
			if i != f.functy.params.len - 1
				o(",")
			;;
			std.htput(namestoparamregs, n, reg)
		| `std.None:
			std.fatal("emit unimplemented param with no name\n")
		;;
	;;
	o(") {{\n")
	ol("@start\n")
	
	for l in f.locals
		alloca = newnamedreg(l.name)
		std.htput(allocas, l, alloca)
		oi("{} =l alloc16 {}\n", valstr(alloca), std.get(typesize(l.ty)))
	;;
	
	for param in f.params
		reg = std.get(std.htget(namestoparamregs, param.name))
		alloca = std.get(std.htget(allocas, param))
		emitstore(alloca, reg)
	;;
	
	for stmt in f.body
		emitstmt(stmt)
	;;
	
	if !unreachable
		ot("ret 0\n")
	;;
	o("}}\n\n")
	std.htfree(allocas)
	std.htfree(namestoparamregs)
}

const emitcall = {call
	var result, args, v

	result = newreg()
	args = [][:]
	for arg in call.args
		v = emitexpr(arg)
		std.slpush(&args, v)
	;;
	match call.func
	| &(`Eident &([.name=name, .sc=`Sclassglobal])):
		oi("{} =l call ${}(", valstr(result), name)
		for var i = 0; i < args.len; i++
			var arg = args[i]
			o("l {}", valstr(arg))
			if i != args.len-1
				o(",")
			;;
		;;
		o(")\n")
	| _:
		std.fatal("function pointers are unimplemented\n")
	;;
	-> result
}


const emitstmt = {stmt
	var v
	
	match stmt
	| &(`Slabeled labeled):
		ol("@L{}\n", labeled.lbl)
		emitstmt(labeled.stmt)
	| &(`Sgoto lbl):
		ot("jmp @L{}\n", lbl)
	| &(`Sreturn expr):
		v = emitexpr(expr)
		ot("ret {}\n", valstr(v))
	| &(`Sexpr expr):
		emitexpr(expr)
	| &(`Sif ifsmt):
		emitif(ifsmt)
	| &(`Swhile whilestmt):
		emitwhile(whilestmt)
 	| &(`Sdowhile dowhilestmt):
		emitdowhile(dowhilestmt)
	| &(`Sfor forstmt):
		emitfor(forstmt)
	| &(`Sblock block):
		for substmt in block
			emitstmt(substmt)
		;;
	| &(`Sdecl _):
		/* do nothing for now */
	| &(`Sempty):
		/* empty */
	;;
}

const emitif = {ifstmt
	var cond
	
	cond = emitexpr(ifstmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), ifstmt.truelbl, ifstmt.falselbl)
	ol("@L{}\n", ifstmt.truelbl)
	emitstmt(ifstmt.iftrue)
	ot("jmp @L{}\n", ifstmt.donelbl)
	ol("@L{}\n", ifstmt.falselbl)
	match ifstmt.iffalse
	| `std.Some iffalse:
		emitstmt(iffalse)
	| `std.None:
	;;
	ol("@L{}\n", ifstmt.donelbl)
}

const emitfor = {forstmt
	var cond
	
	match forstmt.init
	| `std.Some expr:
		emitexpr(expr)
	| `std.None:
	;;
	ol("@L{}\n", forstmt.contlbl)
	match forstmt.cond
	| `std.Some expr:
		cond = emitexpr(expr)
		ot("jnz {}, @L{}, @L{}\n", valstr(cond), forstmt.stmtlbl, forstmt.breaklbl)
	| `std.None:
		ot("jmp @L{}\n", forstmt.stmtlbl)
	;;
	ol("@L{}\n", forstmt.stmtlbl)
	emitstmt(forstmt.stmt)
	match forstmt.step
	| `std.Some expr:
		emitexpr(expr)
	| `std.None:
	;;
	ot("jmp @L{}\n", forstmt.contlbl)
	ol("@L{}\n", forstmt.breaklbl)
}

const emitwhile = {whilestmt
	var cond
	
	ol("@L{}\n", whilestmt.contlbl)
	cond = emitexpr(whilestmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), whilestmt.stmtlbl, whilestmt.breaklbl)
	ol("@L{}\n", whilestmt.stmtlbl)
	emitstmt(whilestmt.stmt)
	ot("jmp @L{}\n", whilestmt.contlbl)
	ol("@L{}\n", whilestmt.breaklbl)
}

const emitdowhile = {whilestmt
	var cond
	
	ol("@L{}\n", whilestmt.stmtlbl)
	emitstmt(whilestmt.stmt)
	ol("@L{}\n", whilestmt.contlbl)
	cond = emitexpr(whilestmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), whilestmt.stmtlbl, whilestmt.breaklbl)
	ol("@L{}\n", whilestmt.breaklbl)
}

const emitlval = {expr
	match expr
	| &(`Eident local):
		-> std.get(std.htget(allocas, local))
	| &(`Eunop [.op=`Oderef, .operand=operand]):
		-> emitexpr(operand)
	| &(`Eidx idx):
		-> emitlidx(idx)
	| &(`Esel sel):
		-> emitlsel(sel)
	| _:
		std.fatal("not an lval\n")
	;;
}

const emitload = {val, ty
	var v
	
	match ty
	| `Tyaggr &(`Tyarr _):
		-> val
	| `Tyaggr &(`Tystruct _):
		-> val
	| _:
	;;
	
	v = newreg()
	match ty
	| `Typrim `Tyint:
		oi("{} =l loadl {}\n", valstr(v), valstr(val))
	| `Tyaggr &(`Typtr _):
		oi("{} =l loadl {}\n", valstr(v), valstr(val))
	| _:
		std.fatal("unimplemented load {}\n", ty)
	;;
	-> v
}

const emitstore = {dst, v
	oi("storel {}, {}\n", valstr(v), valstr(dst))
}

const emitexpr = {expr
	var v1, v2

	match expr
	| &(`Ecall call):
		-> emitcall(call)
	| &(`Eidx idx):
		-> emitidx(idx)
	| &(`Eintlit v):
		-> `Vlit v
	| &(`Ebinop b):
		-> emitbinop(b)
	| &(`Eunop u):
		match u.op
		| `Oaddr:
			-> emitlval(u.operand)
		| `Oderef:
			v1 = emitexpr(u.operand)
			-> emitload(v1, u.ty)
		| _:
			std.fatal("unsupported unop: {}\n", u.op)
		;;
	| &(`Eident local):
		v1 = std.get(std.htget(allocas, local))
		-> emitload(v1, local.ty)
	| &(`Eassign assign):
		v1 = emitlval(assign.l)
		v2 = emitexpr(assign.r)
		emitstore(v1, v2)
		-> v2
	| &(`Esel sel):
		-> emitsel(sel)
	;;
}

const emitlsel = {sel
	var v, p
	
	v = emitexpr(sel.expr)
	p = newreg()
	oi("{} =l add {}, {}\n", valstr(p), valstr(v), sel.off)
	-> p
}

const emitsel = {sel
	var p
	p = emitlsel(sel)
	-> emitload(p, sel.ty)
}

const emitlidx = {idx
	var v, i, p, off, sz
	
	v = emitexpr(idx.expr)
	i = emitexpr(idx.idx)
	off = newreg()
	sz = std.get(typesize(exprtype(idx.expr)))
	oi("{} =l mul {}, {}\n", valstr(off), sz, valstr(i))
	p = newreg()
	oi("{} =l add {}, {}\n", valstr(p), valstr(v), valstr(off))
	-> p
}

const emitidx = {idx
	var p
	
	p = emitlidx(idx)
	-> emitload(p, idx.ty)
}

const emitbinop = {b
	var l, r, o, result
	
	l = emitexpr(b.l)
	r = emitexpr(b.r)
	result = newreg()
	match b.op
	| `Oplus:
		o = "add"
	| `Ominus:
		o = "sub"
	| `Odiv:
		o = "div"
	| `Omul:
		o = "mul"
	| `Omod:
		o = "rem"
	| `Oeq:
		o = "ceql"
	| `One:
		o = "cnel"
	| `Olt:
		o = "csltl"
	| `Ogt:
		o = "csgtl"
	| `Oge:
		o = "csgel"
	| `Ole:
		o = "cslel"
	;;
	oi("{} =l {} {}, {}\n", valstr(result), o, valstr(l), valstr(r))
	-> result
}

