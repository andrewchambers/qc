use std

use "parse"

pkg qc =
	const emit : (globals : node#[:] -> void)
;;

type Val = union
	`Vlit int64
	`Vreg byte[:]
;;

var allocas : std.htab(local#, Val)#
var nreg = 0

const newreg = {
	-> `Vreg std.fmt("%v{}", nreg++) 
}

const newnamedreg = {name
	-> `Vreg std.fmt("%v{}.{}", nreg++, name)
}

const emit = {globals
	for g in globals
		match g
		| &(`Nfunc f):
			emitfunc(f)
		;;
	;;
}

const vo = {msg : byte[:], ap : std.valist#
	var sb, ln

	sb = std.mksb()
	std.sbfmtv(sb, msg, ap)
	ln = std.sbfin(sb)
	match std.writeall(std.Out, ln)
	| (_ ,`std.Some _):
		std.fatal("error writing output\n")
	| _:
	;;
	std.slfree(ln)
}

var unreachable = false

/* output functions abbreviated due to frequent use */
const o = {msg : byte[:], args : ...
	var ap
	
	ap = std.vastart(&args)
	vo(msg, &ap)
}

/* out instruction */
const oi = {msg : byte[:], args : ...
	var ap
	
	if unreachable 
		-> void
	;;
	o("    ")
	ap = std.vastart(&args)
	vo(msg, &ap)
}

/* out label */
const ol = {msg : byte[:], args : ...
	var ap
	
	o("  ")
	ap = std.vastart(&args)
	vo(msg, &ap)
	unreachable = false
}

/* out terminator */
const ot = {msg : byte[:], args : ...
	var ap
	
	o("    ")
	ap = std.vastart(&args)
	vo(msg, &ap)
	unreachable = true
}

const valstr = {v
	match v
	| `Vlit n:
		-> std.fmt("{}", n) 
	| `Vreg name:
		-> name
	;;
}

const emitfunc = {f
	var alloca
	
	allocas = std.mkht({x; -> x castto(uint32)}, {x, y; -> x == y})
	nreg = 0
	
	o("function l ${}(", f.name)
	for (name, ty) in f.args
		o("l {},", name)
	;;
	o(") {{\n")
	ol("@start\n")
	
	for l in f.locals
		alloca = newnamedreg(l.name)
		std.htput(allocas, l, alloca)
		oi("{} =l alloc8 8\n", valstr(alloca))
	;;
	for stmt in f.body
		emitstmt(stmt)
	;;
	
	if !unreachable
		ot("ret 0\n")
	;;
	o("}}\n\n")
	std.htfree(allocas)
}

const emitstmt = {stmt
	var v
	
	match stmt
	| &(`Sreturn expr):
		v = emitexpr(expr)
		ot("ret {}\n", valstr(v))
	| &(`Sexpr expr):
		emitexpr(expr)
	| &(`Sif ifsmt):
		emitif(ifsmt)
	| &(`Swhile whilestmt):
		emitwhile(whilestmt)
 	| &(`Sdowhile dowhilestmt):
		emitdowhile(dowhilestmt)
	| &(`Sfor forstmt):
		emitfor(forstmt)
	| &(`Sblock block):
		for substmt in block
			emitstmt(substmt)
		;;
	| &(`Sdecl _):
		/* do nothing for now */
	| &(`Sempty):
		/* empty */
	;;
}

const emitif = {ifstmt
	var cond
	
	cond = emitexpr(ifstmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), ifstmt.truelbl, ifstmt.falselbl)
	ol("@L{}\n", ifstmt.truelbl)
	emitstmt(ifstmt.iftrue)
	oi("jmp @L{}\n", ifstmt.donelbl)
	ol("@L{}\n", ifstmt.falselbl)
	match ifstmt.iffalse
	| `std.Some iffalse:
		emitstmt(iffalse)
	| `std.None:
	;;
	ol("@L{}\n", ifstmt.donelbl)
}


const emitfor = {forstmt
	var cond
	
	match forstmt.init
	| `std.Some expr:
		emitexpr(expr)
	| `std.None:
	;;
	ol("@L{}\n", forstmt.contlbl)
	match forstmt.cond
	| `std.Some expr:
		cond = emitexpr(expr)
		ot("jnz {}, @L{}, @L{}\n", valstr(cond), forstmt.stmtlbl, forstmt.breaklbl)
	| `std.None:
		ot("jmp @L{}\n", forstmt.stmtlbl)
	;;
	ol("@L{}\n", forstmt.stmtlbl)
	emitstmt(forstmt.stmt)
	match forstmt.step
	| `std.Some expr:
		emitexpr(expr)
	| `std.None:
	;;
	ot("jmp @L{}\n", forstmt.contlbl)
	ol("@L{}\n", forstmt.breaklbl)
}

const emitwhile = {whilestmt
	var cond
	
	ol("@L{}\n", whilestmt.contlbl)
	cond = emitexpr(whilestmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), whilestmt.stmtlbl, whilestmt.breaklbl)
	ol("@L{}\n", whilestmt.stmtlbl)
	emitstmt(whilestmt.stmt)
	ot("jmp @L{}\n", whilestmt.contlbl)
	ol("@L{}\n", whilestmt.breaklbl)
}

const emitdowhile = {whilestmt
	var cond
	
	ol("@L{}\n", whilestmt.stmtlbl)
	emitstmt(whilestmt.stmt)
	ol("@L{}\n", whilestmt.contlbl)
	cond = emitexpr(whilestmt.cond)
	ot("jnz {}, @L{}, @L{}\n", valstr(cond), whilestmt.stmtlbl, whilestmt.breaklbl)
	ol("@L{}\n", whilestmt.breaklbl)
}

const addr = {expr
	match expr
	| &(`Eident `Symlocal local):
		-> std.get(std.htget(allocas, local))
	| &(`Eunop [.op=`Oderef, .operand=operand]):
		-> emitexpr(operand)
	| _:
		std.fatal("not an lval\n")
	;;
}

const load = {val
	var v
	
	v = newreg()
	oi("{} =l loadl {}\n", valstr(v), valstr(val))
	-> v
}

const store = {dst, v
	oi("storel {}, {}\n", valstr(v), valstr(dst))
}

const emitexpr = {expr
	var v1, v2

	match expr
	| &(`Eintlit v):
		-> `Vlit v
	| &(`Ebinop b):
		-> emitbinop(b)
	| &(`Eunop u):
		match u.op
		| `Oaddr:
			-> addr(u.operand)
		| `Oderef:
			v1 = emitexpr(u.operand)
			-> load(v1)
		| _:
			std.fatal("unsupported unop: {}\n", u.op)
		;;
	| &(`Eident `Symlocal local):
		v1 = std.get(std.htget(allocas, local))
		-> load(v1)
	| &(`Eassign assign):
		v1 = addr(assign.l)
		v2 = emitexpr(assign.r)
		store(v1, v2)
		-> v2
	;;
}

const emitbinop = {b
	var l, r, o, result
	
	l = emitexpr(b.l)
	r = emitexpr(b.r)
	result = newreg()
	match b.op
	| `Oplus:
		o = "add"
	| `Ominus:
		o = "sub"
	| `Odiv:
		o = "div"
	| `Omul:
		o = "mul"
	| `Omod:
		o = "rem"
	;;
	oi("{} =l {} {}, {}\n", valstr(result), o, valstr(l), valstr(r))
	-> result
}

