use std
use "ctypes"

pkg qc = 
	
	type node = union
		`Nfunc func#
		`Ndecl (sym#, std.option(expr#))[:]
	;;
	
	type func = struct
		name : byte[:]
		functy : cfunc
		body : stmt#[:]
		locals : sym#[:]
		params : sym#[:]
		lblcnt : int
	;;
	
	type stmt = union
		`Sdecl (sym#, std.option(expr#))[:]
		`Sexpr expr#
		`Sreturn expr#
		`Sblock stmt#[:]
		`Sif ifstmt
		`Sfor forstmt
		`Swhile whilestmt
		`Sdowhile whilestmt
		`Slabeled labeledstmt
		`Sgoto int
		`Sempty
	;;
	
	type ifstmt = struct
		cond : expr#
		iftrue : stmt#
		iffalse : std.option(stmt#)
		truelbl : int
		falselbl : int
		donelbl : int
	;;
	
	type forstmt = struct
		init : std.option(expr#)
		cond : std.option(expr#)
		step : std.option(expr#)
		stmt : stmt#
		contlbl : int
		stmtlbl : int
		breaklbl : int
	;;
	
	type whilestmt = struct
		cond : expr#
		stmt : stmt#
		contlbl : int
		breaklbl : int
		stmtlbl : int
	;;

	type labeledstmt = struct
		stmt : stmt#
		lbl : int
	;;
	
	type expr = union
		`Ebinop binop
		`Eunop unop
		`Eassign assign
		`Eintlit int64
		`Estrlit byte[:]
		`Eident sym#
		`Eidx index
		`Esel selector
		`Ecall call
		`Ecast cast
		`Eincdec incdec
	;;
	
	type cast = struct
		ty : ctype
		expr : expr#
	;;

	
	type selector = struct
		ty : ctype
		expr : expr#
		off : uint32
	;;

	type call = struct
		ty : ctype
		func : expr#
		args : expr#[:]
	;;
	
	type index = struct
		ty : ctype
		expr : expr#
		idx : expr#
	;;
	
	type aop = union
		`Oasn
	;;
	
	type bop = union
		`Oplus
		`Ominus
		`Omul
		`Odiv
		`Omod
		`Oeq
		`One
		`Olt
		`Ogt
		`Oge
		`Ole
		`Oxor
		`Oor
		`Oand
	;;
	
	type uop = union
		`Oaddr
		`Oderef
	;;
	
	type incop = union
		`Opreinc
		`Opredec
		`Opostinc
		`Opostdec
	;;
	
	type incdec = struct
		ty : ctype
		op : incop
		expr : expr#
	;;
	
	type binop = struct
		ty : ctype
		op : bop
		l : expr#
		r : expr#
	;;
	
	type unop = struct
		ty : ctype
		op : uop
		operand : expr#
	;;
	
	type assign = struct
		ty : ctype
		op : aop
		l : expr#
		r : expr#
	;;
	
	type sclass = union
		`Sclasslocal
		`Sclassglobal
		`Sclasstypedef
		`Sclassnone
	;;
	
	type sym = struct
		name : byte[:]
		ty : ctype
		sc : sclass
	;;
	
	const nextlbl : (f : func# -> int)
	const exprtype : (e : expr# -> ctype)
	const islval : (e : expr# -> bool)
;;

// XXX this label count is global until qbe supports func local labels.
var lblcnt = 0

const nextlbl = {f
	-> lblcnt++
	//-> f.lblcnt++
}

const exprtype = {e
	match e
	| &(`Ecast cast):
		-> cast.ty
	| &(`Esel sel):
		-> sel.ty
	| &(`Eident sym):
		-> sym.ty
	| &(`Ebinop bop):
		-> bop.ty
	| &(`Eunop uop):
		-> uop.ty
	| &(`Eassign asn):
		-> asn.ty
	| &(`Eintlit _):
		-> `Typrim `Tyint
	| &(`Estrlit _):
		-> `Tyaggr std.mk(`Typtr `Typrim `Tychar)
	| &(`Eidx idx):
		-> idx.ty
	| &(`Ecall call):
		-> `Typrim `Tyint
	| &(`Eincdec incdec):
		-> exprtype(incdec.expr)
	;;
}

const islval = {n
	match n#
	| `Eunop unop:
		match unop.op
		| `Oderef:
			-> true
		| _:
			-> false
		;;
	| `Eident _:
		-> true
	| `Eidx _:
		-> true
	| `Esel _:
		-> true
	|_:
		-> false
	;;
}
